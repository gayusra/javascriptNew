<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled 3D Rainbow Particles - Neon Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0a0a2e 0%, #000428 50%, #000000 100%);
            font-family: sans-serif;
        }
        
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #ff00ff;
            pointer-events: none;
            opacity: 0.9;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff;
            z-index: 100;
        }

        #handInfo {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #00ff88;
            font-size: 16px;
            pointer-events: none;
            text-shadow: 0 0 8px #00ff88;
            font-weight: bold;
        }

        #videoContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            height: 165px;
            border: 3px solid #ff0080;
            border-radius: 15px;
            overflow: hidden;
            opacity: 0.85;
            box-shadow: 0 0 20px #ff0080;
        }

        canvas {
            display: block;
        }

        /* Animated background overlay */
        .bg-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120,119,198,0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255,119,198,0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120,219,255,0.2) 0%, transparent 50%);
            animation: bgShift 20s ease-in-out infinite alternate;
        }

        @keyframes bgShift {
            0% { transform: scale(1) rotate(0deg); opacity: 0.3; }
            100% { transform: scale(1.1) rotate(1deg); opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="bg-overlay"></div>
    
    <div id="info">âœ¨ Move hands to control RAINBOW particles! âœ¨</div>
    <div id="handInfo">ðŸ‘‹ Hands: <span id="handCount">0</span></div>
    <div id="videoContainer">
        <video id="webcam" autoplay playsinline style="width:100%; height:100%; transform: scaleX(-1);"></video>
    </div>
    <canvas id="webgl"></canvas>

    <!-- Three.js ES Module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP SCENE ---
        const canvas = document.querySelector('#webgl');
        const scene = new THREE.Scene();
        
        // Dynamic neon fog
        scene.fog = new THREE.FogExp2(0x0a0a2e, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 3;

        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // --- 2. CREATE MOVING RAINBOW PARTICLES ---
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 10000;
        const posArray = new Float32Array(particlesCount * 3);
        const velArray = new Float32Array(particlesCount * 3);
        const colorArray = new Float32Array(particlesCount * 3);
        const phaseArray = new Float32Array(particlesCount); // NEW: For rainbow timing

        // Initialize particles with unique phases for rainbow effect
        for(let i = 0; i < particlesCount; i++) {
            const i3 = i * 3;
            
            // Positions
            posArray[i3] = (Math.random() - 0.5) * 8;
            posArray[i3 + 1] = (Math.random() - 0.5) * 8;
            posArray[i3 + 2] = (Math.random() - 0.5) * 8;
            
            // Velocities
            velArray[i3] = (Math.random() - 0.5) * 0.02;
            velArray[i3 + 1] = (Math.random() - 0.5) * 0.02;
            velArray[i3 + 2] = (Math.random() - 0.5) * 0.02;
            
            // Unique phase offset for each particle (creates smooth rainbow waves)
            phaseArray[i] = Math.random() * Math.PI * 2;
            
            // Initialize colors (will be updated dynamically)
            colorArray[i3] = 1.0;
            colorArray[i3 + 1] = 1.0;
            colorArray[i3 + 2] = 1.0;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('velocity', new THREE.BufferAttribute(velArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        particlesGeometry.setAttribute('phase', new THREE.BufferAttribute(phaseArray, 1)); // NEW

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.03,
            vertexColors: true,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // --- 3. HAND TRACKING SETUP (unchanged) ---
        const handCenters = [];
        const videoElement = document.getElementById('webcam');
        const handCountElement = document.getElementById('handCount');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraFeed.start();

        function onHandsResults(results) {
            handCenters.length = 0;
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            handCountElement.textContent = handCount;

            if (results.multiHandLandmarks) {
                for (let landmarks of results.multiHandLandmarks) {
                    let sumX = 0, sumY = 0, sumZ = 0;
                    const palmPoints = [0, 1, 5, 9, 13, 17];
                    for (let idx of palmPoints) {
                        sumX += landmarks[idx].x;
                        sumY += landmarks[idx].y;
                        sumZ += landmarks[idx].z;
                    }
                    
                    const avgX = sumX / palmPoints.length;
                    const avgY = sumY / palmPoints.length;
                    const avgZ = sumZ / palmPoints.length;

                    handCenters.push({
                        x: (avgX - 0.5) * 6,
                        y: -(avgY - 0.5) * 4,
                        z: avgZ * 3
                    });
                }
            }
        }

        // --- 4. ENHANCED ANIMATION LOOP WITH RAINBOW COLORS ---
        const clock = new THREE.Clock();

        const tick = () => {
            const elapsedTime = clock.getElapsedTime();
            
            // === DYNAMIC RAINBOW COLOR ANIMATION (NEW) ===
            const colors = particlesGeometry.attributes.color.array;
            const phases = particlesGeometry.attributes.phase.array;
            
            for(let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                const phase = phases[i] + elapsedTime * 2.0; // Rainbow speed
                
                // HSV to RGB Rainbow conversion
                const hue = (phase % (Math.PI * 2)) / (Math.PI * 2);
                const s = 1.0;
                const v = 1.0;
                
                let c = v * s;
                let x = c * (1 - Math.abs((hue * 6) % 2 - 1));
                let m = v - c;
                let r, g, b;
                
                if (hue * 6 < 1) { r = c; g = x; b = 0; }
                else if (hue * 6 < 2) { r = x; g = c; b = 0; }
                else if (hue * 6 < 3) { r = 0; g = c; b = x; }
                else if (hue * 6 < 4) { r = 0; g = x; b = c; }
                else if (hue * 6 < 5) { r = x; g = 0; b = c; }
                else { r = c; g = 0; b = x; }
                
                colors[i3] = r + m;
                colors[i3 + 1] = g + m;
                colors[i3 + 2] = b + m;
            }
            particlesGeometry.attributes.color.needsUpdate = true;

            const positions = particlesGeometry.attributes.position.array;
            const velocities = particlesGeometry.attributes.velocity.array;

            // Pulsing particle size effect
            particlesMaterial.size = 0.03 + Math.sin(elapsedTime * 3) * 0.01;

            for(let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;

                // Enhanced hand attraction
                for (let hand of handCenters) {
                    const dx = hand.x - positions[i3];
                    const dy = hand.y - positions[i3 + 1];
                    const dz = hand.z - positions[i3 + 2];
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (distance < 2.8 && distance > 0.1) {
                        const forceStrength = (2.8 - distance) / 2.8 * 0.12;
                        velocities[i3] += dx * forceStrength;
                        velocities[i3 + 1] += dy * forceStrength;
                        velocities[i3 + 2] += dz * forceStrength;
                    }
                }

                // Dynamic velocity with sine waves
                velocities[i3] += Math.sin(elapsedTime * 2 + i) * 0.001;
                velocities[i3 + 1] += Math.cos(elapsedTime * 1.5 + i) * 0.001;

                // Damping
                velocities[i3] *= 0.95;
                velocities[i3 + 1] *= 0.95;
                velocities[i3 + 2] *= 0.95;

                // Update position
                positions[i3] += velocities[i3];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];

                // Boundary bounce with energy loss
                if (Math.abs(positions[i3]) > 5) {
                    positions[i3] *= -0.7;
                    velocities[i3] *= -0.6;
                }
                if (Math.abs(positions[i3 + 1]) > 5) {
                    positions[i3 + 1] *= -0.7;
                    velocities[i3 + 1] *= -0.6;
                }
                if (Math.abs(positions[i3 + 2]) > 5) {
                    positions[i3 + 2] *= -0.7;
                    velocities[i3 + 2] *= -0.6;
                }
            }

            particlesGeometry.attributes.position.needsUpdate = true;
            particlesGeometry.attributes.velocity.needsUpdate = true;

            // Smooth multi-axis rotation
            particlesMesh.rotation.y = elapsedTime * 0.025;
            particlesMesh.rotation.x = Math.sin(elapsedTime * 0.002) * 0.15;
            particlesMesh.rotation.z = Math.cos(elapsedTime * 0.0015) * 0.08;

            renderer.render(scene, camera);
            window.requestAnimationFrame(tick);
        };

        tick();

        // --- 5. RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
